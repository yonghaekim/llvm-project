#include "llvm/ACFI/ShadowCallMemPass.h"
#include "llvm/ACFI/ACFI.h"

#define ASSERT(x) if (!(x)) *(voidptr) = 0;

char ShadowCallMemPass::ID = 0;
static RegisterPass<ShadowCallMemPass> X("acfi-scm", "Shadow Call Memory pass");

Pass *llvm::ACFI::createShadowCallMemPass() { return new ShadowCallMemPass(); }

bool ShadowCallMemPass::runOnModule(Module &M) {
	errs() << "Start Shadow Call Mem pass!\n";

	init(M);
  auto const acfiInstType = llvm::ACFI::getAcfiInstType();
  auto const acfiQemuMode = llvm::ACFI::getAcfiQemuMode();

  if (acfiInstType == AcfiType::None) {
	  return false;
	}

  IFCC = (acfiInstType == AcfiType::IFCC);
  PA = (acfiInstType == AcfiType::PA);
  ACFI = (acfiInstType == AcfiType::ACFI);
	QEMU = (acfiQemuMode == AcfiQemuEn::Enable);
	//Relaxed = true;

  if (ACFI) {
    handleInstructions(M);
  	handleWrapperFunctions(M);
  }
	//if (QEMU)
	//  printStoreValues(M);

	return true; // function_modified = true
}

void ShadowCallMemPass::handleInstructions(Module &M) {
  set<Instruction *> store_set;
  set<Instruction *> load_set;
  set<Instruction *> alloca_set;
	set<Instruction *> free_set;

  for (auto &F: M) {
		if (F.getName() == "__init_acfi")
			continue;

    for (auto &BB: F) {
      for (auto &I: BB) {
        switch (I.getOpcode()) {
          case Instruction::Store:
          {
            if (auto pSI = dyn_cast<StoreInst>(&I)) {
              if (auto *pty = dyn_cast<PointerType>(pSI->getValueOperand()->getType())) {
								if (pty->getElementType()->isFunctionTy())
									store_set.insert(&I);
							}
            }

            break;
          }
          case Instruction::Load:
          {
            if (auto pLI = dyn_cast<LoadInst>(&I)) {
              if (auto *pty = dyn_cast<PointerType>(pLI->getType())) {
								if (pty->getElementType()->isFunctionTy())
									load_set.insert(&I);
							}
            }

            break;
          }
          case Instruction::Alloca:
          {
            if (auto pAI = dyn_cast<AllocaInst>(&I)) {
              if (hasFuncPtrTy(pAI->getAllocatedType())) {
                handleAllocaInst(M, pAI);
              }
            }

            break;
          }
          case Instruction::Call:
          case Instruction::Invoke:
          {
						Function *pF = nullptr;

						if (CallInst *pCI = dyn_cast<CallInst>(&I))
            	pF = pCI->getCalledFunction();
						else if (InvokeInst *pII = dyn_cast<InvokeInst>(&I))
            	pF = pII->getCalledFunction();

            if (pF && (pF->getName() == "free" ||
                        pF->getName() == "_ZdlPv" ||
                        pF->getName() == "_ZdaPv")) {
              free_set.insert(&I);
            }

            break;
          }
					default:
						break;
        }
      }
    }
  }

  for (auto pI: store_set) {
		//errs() << "Store: "; pI->dump();
    handleStoreInst(M, dyn_cast<StoreInst>(pI));
	}

  for (auto pI: load_set) {
		//errs() << "Load: "; pI->dump();
    handleLoadInst(M, dyn_cast<LoadInst>(pI));
	}

  for (auto pI: alloca_set)
    handleAllocaInst(M, dyn_cast<AllocaInst>(pI));

  for (auto pI: free_set)
    handleFree(M, pI);
}

void ShadowCallMemPass::handleStoreInst(Module &M, StoreInst *pSI) {
  Value *val_op = pSI->getValueOperand();
  Value *ptr_op = pSI->getPointerOperand();

	auto pty = dyn_cast<PointerType>(val_op->getType());
	auto fty = dyn_cast<FunctionType>(pty->getElementType());
	unsigned num_param = fty->getNumParams();
	auto context = ConstantInt::get(Type::getInt64Ty(*C), num_param);
	//auto zero = ConstantInt::get(Type::getInt64Ty(*C), 0);

	IRBuilder<> Builder(pSI);
	//auto castA = Builder.CreateCast(Instruction::BitCast, ptr_op, Type::getInt8PtrTy(*C));
	//auto castB = Builder.CreatePtrToInt(val_op, Type::getInt64Ty(*C));

	auto callA = insertClosure(M, &Builder, ptr_op, val_op, context);
	pSI->setOperand(0, callA);

	//auto castA = Builder.CreatePtrToInt(ptr_op, Type::getInt64Ty(*C));
	//auto castB = Builder.CreateCast(Instruction::BitCast, val_op, Type::getInt8PtrTy(*C));
	//auto callA = insertClosure(M, &Builder, castA, castB, context);
	//auto castC = Builder.CreateCast(Instruction::BitCast, callA, val_op->getType());
	//pSI->setOperand(0, castC);

	//auto castA = Builder.CreateCast(Instruction::BitCast, val_op, Type::getInt8PtrTy(*C));
	//auto callA = insertAutia(M, &Builder, castA, context);
	//auto castB = Builder.CreateCast(Instruction::BitCast, ptr_op, Type::getInt8PtrTy(*C));
  //auto callB = insertPacda(M, &Builder, castB, zero);
	//auto castC = Builder.CreatePtrToInt(callB, Type::getInt64Ty(*C));
	//auto callC = insertPacia(M, &Builder, callA, castC);
	//auto castD = Builder.CreateCast(Instruction::BitCast, callC, val_op->getType());
	//pSI->setOperand(0, castD);

  //if (llvm::ACFI::getAcfiInstType() == AcfiType::ACFI_SCM) {
	//}
}

void ShadowCallMemPass::handleLoadInst(Module &M, LoadInst *pLI) {
  Value *val_op = pLI;
  Value *ptr_op = pLI->getPointerOperand();

	auto pty = dyn_cast<PointerType>(val_op->getType());
	auto fty = dyn_cast<FunctionType>(pty->getElementType());
	unsigned num_param = fty->getNumParams();
	auto context = ConstantInt::get(Type::getInt64Ty(*C), num_param);
	//auto zero = ConstantInt::get(Type::getInt64Ty(*C), 0);

	IRBuilder<> Builder(pLI->getNextNode());
	//auto castA = Builder.CreateCast(Instruction::BitCast, ptr_op, Type::getInt8PtrTy(*C));
	auto castA = Builder.CreatePtrToInt(ptr_op, Type::getInt64Ty(*C));
	//auto castB = Builder.CreatePtrToInt(val_op, Type::getInt64Ty(*C));
	auto castB = Builder.CreateCast(Instruction::BitCast, val_op, Type::getInt8PtrTy(*C));
	auto callA = insertDisclosure(M, &Builder, castA, castB, context);
	auto castC = Builder.CreateCast(Instruction::BitCast, callA, val_op->getType());

  //auto callA = insertPacda(M, &Builder, castA, zero);
	//auto castC = Builder.CreateCast(Instruction::BitCast, val_op, Type::getInt8PtrTy(*C));
	//auto castD = Builder.CreatePtrToInt(callA, Type::getInt64Ty(*C));
	//auto callB = insertAutia(M, &Builder, castC, castD);
	//auto callC = insertPacia(M, &Builder, callB, context);
	//auto castE = Builder.CreateCast(Instruction::BitCast, callC, val_op->getType());
	pLI->replaceAllUsesWith(castC);
	dyn_cast<Instruction>(castB)->setOperand(0, val_op);
}

void ShadowCallMemPass::handleAllocaInst(Module &M, AllocaInst *pAI) {
	Type *ty = pAI->getAllocatedType();
  auto size_in_bits = pAI->getAllocationSizeInBits(*DL);

	if (size_in_bits == llvm::None)
		return;

  // Check Return Inst
	bool chk = false;
	auto pF = pAI->getFunction();
	Instruction *pIB = nullptr;

	for (auto &BB: *pF) {
		for (auto &I: BB) {
			if (dyn_cast<ReturnInst>(&I)) {
				pIB = &I;
				chk = true;
				break;
			}
		}
	}

  ASSERT(chk); //TODO check
	if (!chk)
		return;

	if (dyn_cast<UnreachableInst>(pIB)) //TODO check
		return;

  FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	Value *size = ConstantInt::get(Type::getInt64Ty(*C), (*size_in_bits) / 8);
  auto scan = M.getOrInsertFunction("__free_scm", FuncTypeA);

	IRBuilder<> Builder(pIB);
	auto castA = Builder.CreateCast(Instruction::BitCast, pAI, Type::getInt8PtrTy(*C));
  Builder.CreateCall(scan, {castA, size});
}

void ShadowCallMemPass::handleFree(Module &M, Instruction *pI) {
	Value *pV = pI->getOperand(0);

	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C)}, false);
  auto scan = M.getOrInsertFunction("__free_scm_heap", FuncTypeA);

	IRBuilder<> Builder(pI);
  Builder.CreateCall(scan, {pV});
}

bool ShadowCallMemPass::hasFuncPtrTy(Type* ty) {
  // Pointer type
  if (auto pty = dyn_cast<PointerType>(ty))
    return pty->getElementType()->isFunctionTy();

  // Array type
  if (ty->isArrayTy()) {
    while (ty->isArrayTy())
      ty = ty->getArrayElementType();

    // Check element type
    if (auto pty = dyn_cast<PointerType>(ty)) {
      if (pty->getElementType()->isFunctionTy())
        return true;
    } else if (auto sty = dyn_cast<StructType>(ty)) {
      for (auto it = sty->element_begin(); it != sty->element_end(); it++) {
        if (hasFuncPtrTy(*it))
          return true;
      }
    }

    return false;
  }

  // Struct type
  if (auto sty = dyn_cast<StructType>(ty)) {
    for (auto it = sty->element_begin(); it != sty->element_end(); it++) {
      if (hasFuncPtrTy(*it))
        return true;
    }

    return false;
  }

  return false;
}

void ShadowCallMemPass::init(Module &M) {
	Function *start = nullptr;

	for (auto &F : M) {
		if (&F && F.getSection().find(".text.startup") != std::string::npos) {
			start = &F;
			break;
		}
	}

	for (auto &F : M) {
		if (&F && F.getName() == "main") {
		  C = &F.getContext();
			DL = &F.getParent()->getDataLayout();
			main = &F;
			if (!start)
				start = main;
			break;
		}
	}

	//FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), false);
	//entry = Function::Create(FuncTypeA, Function::ExternalLinkage, "__init_acfi", M);
	//auto pBB = BasicBlock::Create(*C, "", entry, nullptr);
	//ReturnInst::Create(*C, pBB);

	//auto &BB = start->front();
	//auto &I = BB.front();
	//IRBuilder<> Builder(&I);		
	//Builder.CreateCall(FuncTypeA, entry);
}

void ShadowCallMemPass::handleWrapperFunctions(Module &M) {
	// Handle Call Insts
	set<Instruction*> memset_instset;
	set<Instruction*> memcpy_instset;
	set<Instruction*> memmove_instset;
	set<Instruction*> realloc_instset;
	set<Instruction*> setjmp_instset;
	set<Instruction*> longjmp_instset;

  for (auto &F: M) {
    for (auto &BB: F) {
      for (auto &I: BB) {
        switch (I.getOpcode()) {
          case Instruction::Call:
          case Instruction::Invoke:
          {
						Function *pF = nullptr;

						if (CallInst *pCI = dyn_cast<CallInst>(&I))
            	pF = pCI->getCalledFunction();
						else if (InvokeInst *pII = dyn_cast<InvokeInst>(&I))
            	pF = pII->getCalledFunction();

						if (!pF)
							break;

            if (pF->getName() == "llvm.memset.p0i8.i64")
							memset_instset.insert(&I);
						else if (pF->getName() == "llvm.memcpy.p0i8.p0i8.i64")
							memcpy_instset.insert(&I);
						else if (pF->getName() == "llvm.memmove.p0i8.p0i8.i64")
							memmove_instset.insert(&I);
						else if (pF->getName() == "realloc")
							realloc_instset.insert(&I);
            else if (pF->getName() == "__sigsetjmp" || pF->getName() == "_setjmp")
              setjmp_instset.insert(&I);
            else if (pF->getName() == "siglongjmp" || pF->getName() == "longjmp")
              longjmp_instset.insert(&I);
						break;
					}
					default:
						break;
				}
			}
		}
	}

	for (auto pI: memset_instset)
		handleMemSetInst(M, pI);

	for (auto pI: memcpy_instset)
		handleMemCpyInst(M, pI);

	for (auto pI: memmove_instset)
		handleMemMoveInst(M, pI);

	for (auto pI: realloc_instset)
		handleReallocInst(M, pI);

  if (!QEMU && (PA || ACFI)) {
    for (auto pI: setjmp_instset)
      handleSetJmpInst(M, pI);

    for (auto pI: longjmp_instset)
      handleLongJmpInst(M, pI);
  }

	// Handle use
	set<Instruction*> memset_userset;
	set<Instruction*> memcpy_userset;
	set<Instruction*> memmove_userset;
	set<Instruction*> realloc_userset;
	map<Instruction*, set<Value*>*> user_map;
	map<Value*,Value*> val_map;
	map<GlobalVariable*, set<Value*>*> user_map_gv;
	map<Value*,Value*> val_map_gv;

  for (auto &F: M) {
		if (F.getName() == "memset" ||
				F.getName() == "memcpy" ||
				F.getName() == "memmove" ||
				F.getName() == "realloc") {

			Value *callee;
			if (F.getName() == "memset") {
				FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8Ty(*C), Type::getInt64Ty(*C)}, false);
				auto wrapper = M.getOrInsertFunction("__memset_wrapper", FuncTypeA);
				callee = wrapper.getCallee();
			} else if (F.getName() == "memcpy") {
				FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
				auto wrapper = M.getOrInsertFunction("__memcpy_wrapper", FuncTypeA);
				callee = wrapper.getCallee();
			} else if (F.getName() == "memmove") {
				FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
				auto wrapper = M.getOrInsertFunction("__memmove_wrapper", FuncTypeA);
				callee = wrapper.getCallee();
			} else if (F.getName() == "realloc") {
				FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
				auto wrapper = M.getOrInsertFunction("__realloc_wrapper", FuncTypeA);
				callee = wrapper.getCallee();
			} else if (F.getName() == "__sigsetjmp" ||
                  F.getName() == "_setjmp" ||
                  F.getName() == "siglongjmp" ||
                  F.getName() == "longjmp") {
        ASSERT(false);
      }

			for (auto pU: F.users()) {
				//pU->dump();
				if (auto pI = dyn_cast<Instruction>(pU)) {
					if (!user_map[pI])
						user_map[pI] = new set<Value*>;

					user_map[pI]->insert(callee);
					val_map[callee] = &F;
				} else if (auto pGV = dyn_cast<GlobalVariable>(pU)) {
					if (!user_map_gv[pGV])
						user_map_gv[pGV] = new set<Value*>;

					user_map_gv[pGV]->insert(callee);
					val_map_gv[callee] = &F;
				} else if (auto pBC = dyn_cast<BitCastOperator>(pU)) {
					for (auto pU2: pBC->users()) {
						if (auto pI2 = dyn_cast<Instruction>(pU2)) {
							if (!user_map[pI2])
								user_map[pI2] = new set<Value*>;

							auto pBC2 = ConstantExpr::getBitCast(dyn_cast<Constant>(callee), pBC->getType());
							user_map[pI2]->insert(pBC2);
							val_map[pBC2] = pBC;
						} else {
							pU2->dump();
							ASSERT(false); //TODO
						}
					}
				} else {
					pU->dump();
					ASSERT(false); //TODO
				}
			}
		}
	}	

	for (auto x: user_map) {
		auto pI = x.first;
		for (auto pVa: *x.second) {
			auto pVb = val_map[pVa];
			replaceUser(M, pVb, pVa, pI);
		}
	}

	for (auto x: user_map_gv) {
		auto pGV = x.first;
		for (auto pVa: *x.second) {
			auto pVb = val_map_gv[pVa];
			replaceUserGv(M, pVb, pVa, pGV);
		}
	}
}

void ShadowCallMemPass::handleMemSetInst(Module &M, Instruction *pI) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8Ty(*C), Type::getInt64Ty(*C)}, false);
	auto wrapper = M.getOrInsertFunction("__memset_wrapper", FuncTypeA);

	IRBuilder<> Builder(pI);
	Builder.CreateCall(wrapper, {pI->getOperand(0), pI->getOperand(1), pI->getOperand(2)});
	pI->eraseFromParent();
}

void ShadowCallMemPass::handleMemCpyInst(Module &M, Instruction *pI) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	auto wrapper = M.getOrInsertFunction("__memcpy_wrapper", FuncTypeA);

	IRBuilder<> Builder(pI);
	Builder.CreateCall(wrapper, {pI->getOperand(0), pI->getOperand(1), pI->getOperand(2)});
	pI->eraseFromParent();
}

void ShadowCallMemPass::handleMemMoveInst(Module &M, Instruction *pI) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	auto wrapper = M.getOrInsertFunction("__memmove_wrapper", FuncTypeA);

	IRBuilder<> Builder(pI);
	Builder.CreateCall(wrapper, {pI->getOperand(0), pI->getOperand(1), pI->getOperand(2)});
	pI->eraseFromParent();
}

void ShadowCallMemPass::handleReallocInst(Module &M, Instruction *pI) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	auto wrapper = M.getOrInsertFunction("__realloc_wrapper", FuncTypeA);

	IRBuilder<> Builder(pI);
	auto call = Builder.CreateCall(wrapper, {pI->getOperand(0), pI->getOperand(1)});
	pI->replaceAllUsesWith(call);
	pI->eraseFromParent();
}

void ShadowCallMemPass::handleSetJmpInst(Module &M, Instruction *pI) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt32Ty(*C), {pI->getOperand(0)->getType()}, false);
	auto wrapper = M.getOrInsertFunction("__setjmp_acfi", FuncTypeA);

	IRBuilder<> Builder(pI);
	auto call = Builder.CreateCall(wrapper, {pI->getOperand(0)});
	pI->replaceAllUsesWith(call);
	pI->eraseFromParent();
}

void ShadowCallMemPass::handleLongJmpInst(Module &M, Instruction *pI) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {pI->getOperand(0)->getType(), Type::getInt32Ty(*C)}, false);
	auto wrapper = M.getOrInsertFunction("__longjmp_wrapper", FuncTypeA);

	IRBuilder<> Builder(pI);
	Builder.CreateCall(wrapper, {pI->getOperand(0), pI->getOperand(1)});
	//pI->replaceAllUsesWith(call);
	pI->eraseFromParent();
}

void ShadowCallMemPass::replaceUser(Module &M, Value *pVa, Value *pVb, Instruction *pI) {
	unsigned nth = 0;
	bool chk = false;
	for (auto op = pI->op_begin(); op != pI->op_end(); op++) {
		if (auto *_pV = dyn_cast<Value>(op)) {
			if (_pV == pVa) {
				pI->setOperand(nth, pVb);
				chk = true;
			}
		}

		nth++;
	}
}

void ShadowCallMemPass::replaceUserGv(Module &M, Value *pVa, Value *pVb, GlobalVariable *pGV) {
	unsigned nth = 0;
	bool chk = false;
	for (auto op = pGV->op_begin(); op != pGV->op_end(); op++) {
		if (auto *_pV = dyn_cast<Value>(op)) {
			if (_pV == pVa) {
				pGV->setOperand(nth, pVb);
				chk = true;
			}
		}

		nth++;
	}
}

void ShadowCallMemPass::printStoreValues(Module &M) {
  for (auto &F: M) {
    for (auto &BB: F) {
      for (auto &I: BB) {
				if (auto pSI = dyn_cast<StoreInst>(&I)) {
					IRBuilder<> Builder(&I);
				  FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
				  Value *num = ConstantInt::get(Type::getInt64Ty(M.getContext()), temp_num++);
				  auto print = M.getOrInsertFunction("__print_store", FuncTypeA);

					if (pSI->getValueOperand()->getType()->isPointerTy()) {
				    auto castA = Builder.CreatePtrToInt(pSI->getValueOperand(), Type::getInt64Ty(*C));
				    auto castB = Builder.CreateCast(Instruction::BitCast, pSI->getPointerOperand(), Type::getInt8PtrTy(*C));
				    Builder.CreateCall(print, {castA, castB, num});
					//} else if (pSI->getValueOperand()->getType()->isIntegerTy()) {
				  //  auto castA = Builder.CreateIntCast(pSI->getValueOperand(), Type::getInt64Ty(*C), false);
				  //  auto castB = Builder.CreateCast(Instruction::BitCast, pSI->getPointerOperand(), Type::getInt8PtrTy(*C));
				  //  Builder.CreateCall(print, {castA, castB, num});
					}
				} else if (auto pLI = dyn_cast<LoadInst>(&I)) {
					IRBuilder<> Builder(I.getNextNode());
					FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
					Value *num = ConstantInt::get(Type::getInt64Ty(M.getContext()), temp_num++);
				  auto print = M.getOrInsertFunction("__print_load", FuncTypeA);

					if (pLI->getType()->isPointerTy()) {
				    auto castA = Builder.CreatePtrToInt(pLI, Type::getInt64Ty(*C));
				    auto castB = Builder.CreateCast(Instruction::BitCast, pLI->getPointerOperand(), Type::getInt8PtrTy(*C));
				    Builder.CreateCall(print, {castA, castB, num});
					} else {
						//pLI->dump();
				    //auto castA = Builder.CreateIntToPtr(pLI, Type::getInt8PtrTy(*C));
				    //auto castC = Builder.CreatePtrToInt(castA, Type::getInt64Ty(*C));
				    //auto castB = Builder.CreateCast(Instruction::BitCast, pLI->getPointerOperand(), Type::getInt8PtrTy(*C));
				    //Builder.CreateCall(print, {castC, castB, num});
					}
				}
			}
		}
	}
}

Value *ShadowCallMemPass::insertTagi(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
	if (PA || ACFI) {
    FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
    auto pacia = QEMU? M.getOrInsertFunction("__tagi", FuncTypeA) :
                      Intrinsic::getDeclaration(&M, Intrinsic::acfi_tagi, {Type::getInt8PtrTy(*C)});

    return Builder->CreateCall(pacia, {pV, context}, "");
	} else {
		return dyn_cast<Instruction>(Builder->CreateCast(Instruction::BitCast, pV, Type::getInt8PtrTy(*C)));
	}
}

Value *ShadowCallMemPass::insertTagd(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
	if (PA || ACFI) {
		FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
		auto tagd = QEMU? M.getOrInsertFunction("__tagd", FuncTypeA) :
											Intrinsic::getDeclaration(&M, Intrinsic::acfi_tagd, {Type::getInt8PtrTy(*C)});

		return Builder->CreateCall(tagd, {pV, context}, "");
	} else {
		return dyn_cast<Instruction>(Builder->CreateCast(Instruction::BitCast, pV, Type::getInt8PtrTy(*C)));
	}
}

Instruction *ShadowCallMemPass::insertAuti(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
	if (PA || ACFI) {
		FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C), Type::getInt64Ty(*C)}, false);
		Value *num = ConstantInt::get(Type::getInt64Ty(*C), temp_num++);

		if (QEMU) {
			auto autia = M.getOrInsertFunction("__auti", FuncTypeA);
			return Builder->CreateCall(autia, {pV, context, num}, "");
		} else {
			auto autia = Intrinsic::getDeclaration(&M, Intrinsic::acfi_auti, {Type::getInt8PtrTy(*C)});
			return Builder->CreateCall(autia, {pV, context}, "");
		}
	} else {
		return dyn_cast<Instruction>(Builder->CreateCast(Instruction::BitCast, pV, Type::getInt8PtrTy(*C)));
	}
}

void ShadowCallMemPass::insertBsetm(Module &M, IRBuilder<> *Builder, Value *pV) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C)}, false);
	auto bsetm = QEMU? M.getOrInsertFunction("__bsetm", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::acfi_bsetm);
	Builder->CreateCall(bsetm, {pV}, "");
}

Value *ShadowCallMemPass::insertClosure(Module &M, IRBuilder<> *Builder, Value *ptr_op, Value *val_op, Value *context) {
  if (ACFI) {
    auto castA = Builder->CreateCast(Instruction::BitCast, ptr_op, Type::getInt8PtrTy(*C));
    auto castB = Builder->CreateCast(Instruction::BitCast, val_op, Type::getInt8PtrTy(*C));
    auto castC = Builder->CreatePtrToInt(ptr_op, Type::getInt64Ty(*C));
    insertBsetm(M, Builder, castA);
    auto callA = insertTagi(M, Builder, castB, castC);
    auto castD = dyn_cast<Instruction>(Builder->CreateCast(Instruction::BitCast, callA, val_op->getType()));
    return castD;
  } else {
		return val_op;
  }
}

Value *ShadowCallMemPass::insertDisclosure(Module &M, IRBuilder<> *Builder, Value *ptr_op, Value *val_op, Value *context) {
  if (ACFI) {
		if (Relaxed) {
			auto tagi = insertTagi(M, Builder, val_op, context);
			return tagi;
		} else {
			auto auti = insertAuti(M, Builder, val_op, ptr_op);
			auto tagi = insertTagi(M, Builder, auti, context);
			return tagi;
		}
  } else {
		return val_op;
  }
}

void ShadowCallMemPass::handleBitCastInsts(Module &M) {
	for (auto &F: M) {
		for (auto &BB: F) {
			for (auto &I: BB) {
				if (auto pBC = dyn_cast<BitCastInst>(&I)) {
					if (pBC->getSrcTy()->isPointerTy()) {
						auto src_pty = dyn_cast<PointerType>(pBC->getSrcTy());
						auto dst_pty = dyn_cast<PointerType>(pBC->getDestTy());

						if (!src_pty->getElementType()->isFunctionTy() &&
								dst_pty->getElementType()->isFunctionTy()) {
							pBC->dump();
						}
					}
				}
			}
		}
	}
}

//void ShadowCallMemPass::printFuncAddr(Module &M) {
//	auto &BB = entry->front();
//	auto &I = BB.front();
//	IRBuilder<> Builder(&I);
//
//	for (auto &F : M) {
//		if (&F && !F.isDeclaration()) {
//			Constant *name = ConstantDataArray::getString(*C, F.getName(), true);
//
//			GlobalVariable* pGV = new GlobalVariable(M, 
//        /*Type=*/ name->getType(),
//        /*isConstant=*/ true,
//        /*Linkage=*/ GlobalValue::PrivateLinkage,
//        /*Initializer=*/ 0, // has initializer, specified below
//        /*Name=*/ ".func_name");
//			pGV->setAlignment(1);
//			pGV->setInitializer(name);
//
//			auto castA = Builder.CreateCast(Instruction::BitCast, pGV, Type::getInt8PtrTy(*C));
//			auto castB = Builder.CreateCast(Instruction::BitCast, &F, Type::getInt8PtrTy(*C));
//			FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C)}, false);
//			auto print = M.getOrInsertFunction("__print_func", FuncTypeA);
//			Builder.CreateCall(print, {castA, castB});
//		}
//	}
//}
//
//void ShadowCallMemPass::insertAcfiSet(Module &M) {
//  //for (auto &F : M) {
//  //  if (&F && !F.isDeclaration()) {
//  //    auto &BB = F.front();
//  //    auto &I = BB.front();
//  //    IRBuilder<> Builder(&I);
//
//  //    Value *arg = ConstantInt::get(Type::getInt64Ty(M.getContext()), func_num++);
//  //    FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(M.getContext())}, false);
//  //    auto print = F.getParent()->getOrInsertFunction("dpt_print_func", FuncTypeA);
//  //    Builder.CreateCall(print, {arg});
//
//	//		for (auto &BB: F) {
//	//			for (auto &I: BB) {
//	//				if (dyn_cast<ReturnInst>(&I)) {
//	//					IRBuilder<> BuilderB(&I);
//
//	//					Value *arg = ConstantInt::get(Type::getInt64Ty(M.getContext()), func_num-1);
//	//					FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(M.getContext())}, false);
//	//					auto print = F.getParent()->getOrInsertFunction("dpt_print_func_ret", FuncTypeA);
//	//					BuilderB.CreateCall(print, {arg});
//	//					break;
//	//				}
//	//			}
//	//		}
//
//  //  }
//  //}
//
//	// Insert acfi_set() to init configuration
//	auto &BB = entry->front();
//	auto &I = BB.front();
//	IRBuilder<> Builder(&I);
//
//	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), false);
//	auto init = M.getOrInsertFunction("__acfi_set", FuncTypeA);
//	Builder.CreateCall(init);
//}
