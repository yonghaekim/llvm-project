#include "llvm/ACFI/MCPass.h"
#include "llvm/ACFI/ACFIPass.h"
#include "llvm/ACFI/ACFI.h"
#include "llvm/IR/InlineAsm.h"

#define ASSERT(x) if (!(x)) *(voidptr) = 0;

char MCPass::ID = 0;
static RegisterPass<MCPass> X("acfi-mc", "ACFI + MAC closure pass");

Pass *llvm::ACFI::createMCPass() { return new MCPass(); }

bool MCPass::runOnModule(Module &M) {
	errs() << "Start MC pass!\n";

	init(M);
  auto const acfiInstType = llvm::ACFI::getAcfiInstType();
  auto const acfiQemuMode = llvm::ACFI::getAcfiQemuMode();

	//printFuncNum(M);
	QEMU = (acfiQemuMode == AcfiQemuEn::Enable);

	handleInstructions(M);
  handleWrapperFunctions(M);
	handleIntToPtrInsts(M);

	//for (auto &F: M) {
  //  for (auto &BB: F) {
  //    for (auto &I: BB) {
	//			bool found = false;
	//			Value *ptr = nullptr;

  //      if (LoadInst *pLI = dyn_cast<LoadInst>(&I)) {
	//				found = true;
	//				ptr = pLI->getOperand(0);
  //      } else if (StoreInst *pSI = dyn_cast<StoreInst>(&I)) {
	//				found = true;
	//				ptr = pSI->getOperand(1);
	//			}

	//			if (found) {
	//				IRBuilder<> Builder(&I);
	//				auto castA = Builder.CreateCast(Instruction::BitCast, ptr, Type::getInt8PtrTy(*C));
	//				//FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C)}, false);
	//				//auto check = M.getOrInsertFunction("__check", FuncTypeA);
	//				//auto callA = Builder.CreateCall(check, {castA}, "");
	//				Value *num = ConstantInt::get(Type::getInt64Ty(*C), temp_cnt++);
	//				FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	//				auto check = M.getOrInsertFunction("__print_value", FuncTypeA);
	//				Builder.CreateCall(check, {castA, num}, "");
	//			}
	//		}
	//	}
	//}

	return false; // function_modified = false
}

void MCPass::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.setPreservesAll();
  AU.addRequired<ACFIPass> ();
}

void MCPass::handleInstructions(Module &M) {
  set<StoreInst*> store_set;
  set<LoadInst*> load_set;
  set<AllocaInst*> alloca_set;
	set<CallBase*> free_set;

  for (auto &F: M) {
		if (F.getName() == "__acfi_set" ||
		    F.getName() == "__init_acfi")
			continue;

		if (F.getSection().find(".text.startup") != std::string::npos)
      continue;

    for (auto &BB: F) {
      for (auto &I: BB) {
				if (auto pSI = dyn_cast<StoreInst>(&I)) {
					auto *pty = dyn_cast<PointerType>(pSI->getValueOperand()->getType());
					if (pty && pty->getElementType()->isFunctionTy())
						store_set.insert(pSI);
				} else if (auto pLI = dyn_cast<LoadInst>(&I)) {
					auto *pty = dyn_cast<PointerType>(pLI->getType());
					if (pty && pty->getElementType()->isFunctionTy())
						load_set.insert(pLI);
				} else if (auto pAI = dyn_cast<AllocaInst>(&I)) {
					if (hasFuncPtrTy(pAI->getAllocatedType()))
						alloca_set.insert(pAI);
        }
			}
		}
  }

  for (auto pSI: store_set)
    handleStoreInst(M, pSI);

  for (auto pLI: load_set)
    handleLoadInst(M, pLI);

  for (auto pAI: alloca_set)
    handleAllocaInst(M, pAI);
}

void MCPass::handleStoreInst(Module &M, StoreInst *pSI) {
  Value *ptr_op = pSI->getPointerOperand();
  Value *val_op = pSI->getValueOperand();

	auto pty = dyn_cast<PointerType>(val_op->getType());
	auto fty = dyn_cast<FunctionType>(pty->getElementType());
	unsigned num_param = fty->getNumParams();
	auto context = ConstantInt::get(Type::getInt64Ty(*C), num_param);
	//auto zero = ConstantInt::get(Type::getInt64Ty(*C), 0);

	IRBuilder<> Builder(pSI);

  // MAC Closure sequence
	// bset ptr_op
	// tagc val_op, val_op, ptr_op
	// store val_op, ptr_op
	auto castA = Builder.CreateCast(Instruction::BitCast, ptr_op, Type::getInt8PtrTy(*C));
	insertBsetm(M, &Builder, castA);
	auto castB = Builder.CreateCast(Instruction::BitCast, val_op, Type::getInt8PtrTy(*C));
	auto castC = Builder.CreatePtrToInt(ptr_op, Type::getInt64Ty(*C));
	auto callA = insertTagc(M, &Builder, castB, castC);
	auto castD = dyn_cast<Instruction>(Builder.CreateCast(Instruction::BitCast, callA, val_op->getType()));

	pSI->setOperand(0, castD);
}

void MCPass::handleLoadInst(Module &M, LoadInst *pLI) {
  Value *val_op = pLI;
  Value *ptr_op = pLI->getPointerOperand();

	auto pty = dyn_cast<PointerType>(val_op->getType());
	auto fty = dyn_cast<FunctionType>(pty->getElementType());
	unsigned num_param = fty->getNumParams();
	auto context = ConstantInt::get(Type::getInt64Ty(*C), num_param);
	//auto zero = ConstantInt::get(Type::getInt64Ty(*C), 0);

  // MAC disclosure sequence
  // val_op = load ptr_op
  // autc val_op, ptr_op
  // tagc val_op, context
	IRBuilder<> Builder(pLI->getNextNode());
	auto castA = Builder.CreateCast(Instruction::BitCast, val_op, Type::getInt8PtrTy(*C));
	auto castB = Builder.CreatePtrToInt(ptr_op, Type::getInt64Ty(*C));

	//if (Relaxed) { //TODO check
	//	auto tagc = insertTagc(M, &Builder, val_op, context);
	//} else {
		auto callA = insertAutc(M, &Builder, castA, castB);
		auto callB = insertTagc(M, &Builder, callA, context);
	//}

	auto castC = Builder.CreateCast(Instruction::BitCast, callB, val_op->getType());

	pLI->replaceAllUsesWith(castC);
	dyn_cast<Instruction>(castA)->setOperand(0, val_op);
}

void MCPass::handleAllocaInst(Module &M, AllocaInst *pAI) {
	Type *ty = pAI->getAllocatedType();
  auto size_in_bits = pAI->getAllocationSizeInBits(*DL);

	if (size_in_bits == llvm::None)
		return;

  // Check Return Inst
	bool chk = false;
	auto pF = pAI->getFunction();
	Instruction *pIB = nullptr;

	for (auto &BB: *pF) {
		for (auto &I: BB) {
			if (dyn_cast<ReturnInst>(&I)) {
				pIB = &I;
				chk = true;
				break;
			}
		}
	}

  ASSERT(chk); //TODO check
	if (!chk)
		return;

	if (dyn_cast<UnreachableInst>(pIB)) //TODO check
		return;

	// TODO: if pAI is function pointer variable, just insert bclrm

  //FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
  FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C), Type::getInt64Ty(*C)}, false);
  Value *num = ConstantInt::get(Type::getInt64Ty(*C), temp_cnt++);
	Value *size = ConstantInt::get(Type::getInt64Ty(*C), (*size_in_bits) / 8);
  //auto clear = M.getOrInsertFunction("__clear_wpb", FuncTypeA);
  auto clear = M.getOrInsertFunction("__clear_wpb_num", FuncTypeA);

	IRBuilder<> Builder(pIB);
	auto castA = Builder.CreateCast(Instruction::BitCast, pAI, Type::getInt8PtrTy(*C));
  Builder.CreateCall(clear, {castA, size, num});
}

bool MCPass::hasFuncPtrTy(Type* ty) {
  // Pointer type
  if (auto pty = dyn_cast<PointerType>(ty))
    return pty->getElementType()->isFunctionTy();

  // Array type
  if (ty->isArrayTy()) {
    while (ty->isArrayTy())
      ty = ty->getArrayElementType();

    // Check element type
    if (auto pty = dyn_cast<PointerType>(ty)) {
      if (pty->getElementType()->isFunctionTy())
        return true;
    } else if (auto sty = dyn_cast<StructType>(ty)) {
      for (auto it = sty->element_begin(); it != sty->element_end(); it++) {
        if (hasFuncPtrTy(*it))
          return true;
      }
    }

    return false;
  }

  // Struct type
  if (auto sty = dyn_cast<StructType>(ty)) {
    for (auto it = sty->element_begin(); it != sty->element_end(); it++) {
      if (hasFuncPtrTy(*it))
        return true;
    }

    return false;
  }

  return false;
}

void MCPass::handleWrapperFunctions(Module &M) {
  Function *memset = nullptr;
  Function *memcpy = nullptr;
  Function *memmove = nullptr;
  Function *sigsetjmp = nullptr;
  Function *setjmp = nullptr;
  Function *siglongjmp = nullptr;
  Function *longjmp = nullptr;

  for (auto &F: M) {
    if (F.getName() == "llvm.memset.p0i8.i64")
      memset = &F;
    else if (F.getName() == "llvm.memcpy.p0i8.p0i8.i64")
      memcpy = &F;
    else if (F.getName() == "llvm.memmove.p0i8.p0i8.i64")
      memmove = &F;
    else if (F.getName() == "__sigsetjmp")
      sigsetjmp = &F;
    else if (F.getName() == "_setjmp")
      setjmp = &F;
    else if (F.getName() == "siglongjmp")
      siglongjmp = &F;
    else if (F.getName() == "longjmp")
      longjmp = &F;
  }

  if (memset) {
    FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8Ty(*C), Type::getInt64Ty(*C), Type::getInt1Ty(*C)}, false);
    auto wrapper = M.getOrInsertFunction("__memset_wrapper", FuncTypeA);
		auto callee = wrapper.getCallee();
    memset->replaceAllUsesWith(callee);
  }

  if (memcpy) {
    FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C), Type::getInt1Ty(*C)}, false);
    auto wrapper = M.getOrInsertFunction("__memcpy_wrapper", FuncTypeA);
		auto callee = wrapper.getCallee();
    memcpy->replaceAllUsesWith(callee);
  }

  if (memmove) {
		FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C), Type::getInt1Ty(*C)}, false);
    auto wrapper = M.getOrInsertFunction("__memmove_wrapper", FuncTypeA);
		auto callee = wrapper.getCallee();
    memmove->replaceAllUsesWith(callee);
  }

  //if (sigsetjmp) {
  //  FunctionType *FuncTypeA = FunctionType::get(Type::getInt32Ty(*C), {pI->getOperand(0)->getType()}, false);
  //  auto wrapper = M.getOrInsertFunction("__setjmp_cpt", FuncTypeA);
	//	auto callee = wrapper.getCallee();
  //  sigsetjmp->replaceAllUsesWith(callee);
  //}

  //if (setjmp) {
  //  FunctionType *FuncTypeA = FunctionType::get(Type::getInt32Ty(*C), {pI->getOperand(0)->getType()}, false);
  //  auto wrapper = M.getOrInsertFunction("__setjmp_cpt", FuncTypeA);
	//	auto callee = wrapper.getCallee();
  //  setjmp->replaceAllUsesWith(callee);
  //}

  //if (siglongjmp) {
  //  FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {pI->getOperand(0)->getType(), Type::getInt32Ty(*C)}, false);
  //  auto wrapper = M.getOrInsertFunction("__longjmp_wrapper", FuncTypeA);
	//	auto callee = wrapper.getCallee();
  //  siglongjmp->replaceAllUsesWith(callee);
  //}

  //if (longjmp) {
  //  FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {pI->getOperand(0)->getType(), Type::getInt32Ty(*C)}, false);
  //  auto wrapper = M.getOrInsertFunction("__longjmp_wrapper", FuncTypeA);
	//	auto callee = wrapper.getCallee();
  //  longjmp->replaceAllUsesWith(callee);
  //}

  // realloc will be handled using hook
}

void MCPass::handleIntToPtrInsts(Module &M) {
	for (auto &F: M) {
    for (auto &BB: F) {
      for (auto &I: BB) {
				if (auto pII = dyn_cast<IntToPtrInst>(&I)) {
					auto ty = dyn_cast<PointerType>(pII->getType());
					if (auto fty = dyn_cast<FunctionType>(ty)) {
						errs() << "pII: "; pII->dump();

						IRBuilder<> Builder(pII->getNextNode());
						unsigned num_param = fty->getNumParams();
						auto context = ConstantInt::get(Type::getInt64Ty(*C), num_param);
						auto callA = insertTagc(M, &Builder, pII, context);
						auto castA = Builder.CreateCast(Instruction::BitCast, callA, pII->getType());
						pII->replaceAllUsesWith(castA);
					}
				} else if (auto pPI = dyn_cast<PtrToIntInst>(&I)) {
					//errs() << "pPI: "; pPI->dump();
				} else if (auto pBC = dyn_cast<BitCastInst>(&I)) {
					auto src_pty = dyn_cast<PointerType>(pBC->getSrcTy());
					auto dst_pty = dyn_cast<PointerType>(pBC->getDestTy());

					if (src_pty && dst_pty && !src_pty->getElementType()->isFunctionTy() &&
							dst_pty->getElementType()->isFunctionTy()) {
						//errs() << "pBC: "; pBC->dump();
					}
				}
			}
		}
	}
}

Value *MCPass::insertTagc(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
  FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
  //auto castA = Builder->CreateCast(Instruction::BitCast, pV, Type::getInt8PtrTy(*C));
	Value *castA = nullptr;

	if (pV->getType()->isPointerTy())
		castA = Builder->CreateCast(Instruction::BitCast, pV, Type::getInt8PtrTy(*C));
	else
		castA = Builder->CreateIntToPtr(pV, Type::getInt8PtrTy(*C));

  auto tagc = QEMU? M.getOrInsertFunction("__tagc", FuncTypeA) :
                    Intrinsic::getDeclaration(&M, Intrinsic::pa_tagc, {Type::getInt8PtrTy(*C)});

  return Builder->CreateCall(tagc, {castA, context}, "");
}

Value *MCPass::insertAutc(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
  FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C), Type::getInt64Ty(*C)}, false);
  Value *num = ConstantInt::get(Type::getInt64Ty(*C), temp_cnt++);

  if (QEMU) {
    auto autc = M.getOrInsertFunction("__autc", FuncTypeA);
    return Builder->CreateCall(autc, {pV, context, num}, "");
  } else {
    auto autc = Intrinsic::getDeclaration(&M, Intrinsic::pa_autc, {Type::getInt8PtrTy(*C)});
    return Builder->CreateCall(autc, {pV, context}, "");
  }
}

void MCPass::insertEstr(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	auto estr = QEMU? M.getOrInsertFunction("__estr", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::acfi_estr);
	Builder->CreateCall(estr, {pV, context}, "");
}

void MCPass::insertEact(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	auto eact = QEMU? M.getOrInsertFunction("__eact", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::acfi_eact);
	Builder->CreateCall(eact, {pV, context}, "");
}

void MCPass::insertEchk(Module &M, IRBuilder<> *Builder, Value *pV, Value *context) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	auto eact = QEMU? M.getOrInsertFunction("__echk", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::acfi_echk);
	Builder->CreateCall(eact, {pV, context}, "");
}

void MCPass::insertBsetm(Module &M, IRBuilder<> *Builder, Value *pV) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C)}, false);
	auto bsetm = QEMU? M.getOrInsertFunction("__bsetm", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::bm_bsetm);
	Builder->CreateCall(bsetm, {pV}, "");
}

void MCPass::init(Module &M) {
	for (auto &F : M) {
		if (&F && F.getName() == "main") {
		  C = &F.getContext();
			DL = &F.getParent()->getDataLayout();
			main = &F;
			break;
		}
	}
}
